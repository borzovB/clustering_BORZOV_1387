import numpy as np

class LinearRegression:
    #['Остаточное количество', 'разрешение', 'Структура и молекулярный вес', 'Температура кристаллизации',
     #'Плотность в матрицах', 'Плотность в процентах от соли', 'Значение рН', 'Год публикации']
    def __init__(self):
        self.coefficients = None # Тут хранятся обученные коэффициенты для дальнейшей генерации
    # Функция для обучения
    def fit(self, X, y):
        X = np.hstack([np.ones((X.shape[0], 1)), X]) # Добавление к матрице первого столбца и заполнение значением 1
        # Необходимо для того, чтобы линия графика не начиналась из точки [0,0], потому что значения не могут быть равна 0

        try:
            XtX = np.dot(X.T, X)  # находим транспорированную матрицу и умножаем на обычную матрицу
            # формула XtX = X^T * X, это необходимо, чтобы связать свойства (значения в столбцах между собой)
            XtX_inv = np.linalg.inv(XtX)  # Находим инвертируемую матрицу
            # Формула (X^T * X)^(-1)
            # Далее проводим связывание с матрицей y и параметрами
            # Xty = X^T * y
            XtX_y = np.dot(X.T, y)
            # w = (X^T * X)^{-1} * X^T * y

            self.coefficients = np.dot(XtX_inv, XtX_y)
        except np.linalg.LinAlgError:
            # Есть несколько причин возникновения исключения это вырожденная матрица, столбцы в X слишком близки друг
            # к другу, много пропусков
            al = 1e-6; # Слишком маленькое число может сделать регуляризацию бесполезной, а если брать слишком
            # большое число это может повлиять на W
            # XtX = XtX + alpha * I(I — единичная матрица), формула регуляризации
            XtX += al * np.eye(X.shape[1])
            # Единичная матрица все элементы 0, кроме диагонали

            XtX_inv = np.linalg.inv(XtX)
            XtX_y = np.dot(X.T,y)
            self.coefficients = np.dot(XtX_inv, XtX_y)

    # Функция для генерации новых значений на основе ранее полученных коэффициентов
    def predict(self, X):
        X = np.hstack([np.ones((X.shape[0], 1)), X])
        print("Reg3")
        return np.dot(X, self.coefficients)
